//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 3? 16 2016 10:57:30
//
//      Input file      : 
//      Component name  : morph_2d
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


	module Morph_2D(
		rst_n,//异步复位信号
		clk,//同步时钟信号
		din_valid,//输入数据有效信号
		din,//输入数据流 
		dout,//输出数据流 
		vsync,//输入场同步信号 
		vsync_out,//输出场同步信号
		dout_valid//舒小虎数据有效信号
	);
	
	parameter       DW = 14;//数据位宽
	parameter       KSZ = 7;//处理尺寸
	parameter       IH = 512;//图像高度
	parameter       IW = 640;//图像宽度
	parameter       ERO_DIA = 1;//腐蚀或膨胀选择
	input           rst_n;
	input           clk;
	input           din_valid;
	input [DW-1:0]  din;
	output [DW-1:0] dout;
	input           vsync;
	output          vsync_out;
	output          dout_valid;
   
	localparam       radius = ((KSZ >> 1));
	localparam       num_all = KSZ * KSZ;
	localparam       fifo_num = KSZ - 1;
	localparam       med_idx = ((num_all >> 1));
   
	reg             rst_all;
	reg [DW-1:0]    line_din[0:KSZ-2];
	wire [DW-1:0]   line_dout[0:KSZ-2];
	wire [KSZ-2:0]  line_empty;
	wire [KSZ-2:0]  line_full;
	wire [KSZ-2:0]  line_rden;
	reg [KSZ-2:0]   line_wren;
	wire [9:0]      line_count[0:KSZ-2];

	wire [DW-1:0]   min_max_value;
	wire [DW-1:0]   min_max_value_r;
	wire            din_valid_r;
	reg [DW-1:0]    min[0:KSZ-1];
	reg [DW-1:0]    max[0:KSZ-1];

	reg [KSZ-2:0]   buf_pop_en;
	reg             valid_r;

	reg [10:0]      in_line_cnt;
	reg [15:0]      flush_cnt;
	reg             flush_line;
	reg [15:0]      out_pixel_cnt;
	reg [10:0]      out_line_cnt;
	reg [DW-1:0]    dout_temp_r;
	reg             dout_valid_temp_r;
	wire [DW-1:0]   dout_temp;
	wire            dout_valid_temp;
	wire            is_boarder;
	wire            valid;
	reg             din_valid_r2;

	wire [31:0]     j;
	wire [31:0]     k;

	wire            rst_all_low;
	wire            data_tmp1[0:KSZ-2];
	wire [DW-1:0]   data_tmp2;
	wire [DW-1:0]   data_tmp3;
   
  //帧同步复位信号 
	always @(posedge clk or posedge rst_n)
	if (((~(rst_n))) == 1'b1)
		 rst_all <= #1 1'b1;
	else 
	begin
		 if (vsync == 1'b1)
				rst_all <= #1 1'b1;
		 else
				rst_all <= #1 1'b0;
	end
  //低电平帧同步复位信号  
  assign rst_all_low = (~(rst_all));
  //全局有效信号 
  assign valid = din_valid | flush_line;
  //1维方向上的Morph操作 
  Morph_1D #(DW, KSZ, ERO_DIA)
		row_1st(
			.rst_n(rst_all_low), 
			.clk(clk), 
			.din(din),
			.din_valid(valid), 
			.dout_valid(din_valid_r),//1维输出有效信号 
			.dout(min_max_value)//1维输出min_max_value
		);
   
  //缓存1维输出有效信号用于时序对齐 
  always @(posedge clk)
		din_valid_r2 <= #1 din_valid_r;
   
  always @(*) min[0] <= min_max_value; 
  always @(*) max[0] <= min_max_value;
   
  generate
  begin : xhdl0
    genvar          i;
    for (i = 0; i <= KSZ - 2; i = i + 1)
    begin : buf_cmp_inst
      
			assign data_tmp1[i] = din_valid_r & line_rden[i];//输入有效信号
      //例化列方向上的比较电路     
			MinMax #(DW, 1)
				cmp_inst(
					clk, 
					data_tmp1[i], 
					line_dout[i], 
					min_max_value, 
					min[i + 1],
					max[i + 1]
				);
            
			if (ERO_DIA == 1)
			begin : MAP10
				always @(*) line_din[i] <= min[i];//腐蚀取最小值
			end
			
			if ((~(ERO_DIA == 1)))
			begin : MAP11
				always @(*) line_din[i] <= max[i];//膨胀取最大值
			end
            
			if (i == 0)
			begin : MAP12
				always @(din_valid_r)
					line_wren[i] <= din_valid_r;//第一个行缓存的输入为一维输出数据
			end
            
			if ((~(i == 0)))
			begin : MAP13 
				always @(posedge clk)
				begin
					if (rst_all == 1'b1)
						line_wren[i] <= 1'b0;
					else
						line_wren[i] <= #1 line_rden[i - 1];//其他行缓存接成菊花链结构
				end
			end
            
      assign line_rden[i] = buf_pop_en[i] & din_valid_r;
      //行缓存装满后允许流水线开始运行          
			always @(posedge clk)
			begin
				if (rst_all == 1'b1)
					buf_pop_en[i] <= #1 1'b0;
				else if (line_count[i] == IW)
					buf_pop_en[i] <= #1 1'b1;
			end
      //例化行缓存      
      line_buffer #(DW, IW) 
				line_buf_inst(
					.rst(rst_all), 
					.clk(clk), 
					.din(line_din[i]), 
					.dout(line_dout[i]),
					.wr_en(line_wren[i]), 
					.rd_en(line_rden[i]), 
					.empty(line_empty[i]), 
					.full(line_full[i]), 
					.count(line_count[i])
				);
    end
  end
  endgenerate
   
	generate
	if (ERO_DIA == 1)
	begin : MAP14
		 assign dout_temp = ((line_rden[KSZ - 2] == 1'b0)) ? min[radius] : 
												min[KSZ - 1];
	end
	endgenerate
   
	generate
	if ((~(ERO_DIA == 1)))
	begin : MAP15
		 assign dout_temp = ((line_rden[KSZ - 2] == 1'b0)) ? max[radius] : 
												max[KSZ - 1];
	end
	endgenerate
   
endmodule





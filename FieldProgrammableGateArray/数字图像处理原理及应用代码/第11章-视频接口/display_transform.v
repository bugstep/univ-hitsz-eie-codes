//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 3? 16 2016 10:55:05
//
//      Input file      : 
//      Component name  : display_transform
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

`timescale 1ps/1ps

module display_transform(
		clk, 
		vsync, 
		din, 
		dvalid, 
		dout,
		dout_valid, 
		min_value,
		max_value, 
		lowIndex, 
		highIndex, 
		shift_pos, 
		alg_sel
	);
	
	input  clk;
	input  vsync;
	input  [13:0]din;
	input  dvalid;
	output reg[7:0]dout;

	output reg dout_valid;
	output [13:0] min_value;
	output [13:0] max_value;
	input  [13:0]  lowIndex;
	input  [13:0]  highIndex;
	input  [2:0]   shift_pos;
	input  [1:0]   alg_sel;

	reg  [13:0]    min_pixel;
	reg  [13:0]    max_pixel;
	wire [13:0]   max_pixel_sel;
	wire [13:0]   min_pixel_sel;
	reg  [13:0]    diff;
	wire [15:0]   quotient;
	reg  [15:0]    slope;
	reg  [2:0]     shift_pos_shadow;
	reg  [7:0]     shift_dout;
	reg  [13:0]    linear_shadow_pre;
	reg  [29:0]    linear_shadow_pos;
	reg  [7:0]     linear_dout;
	reg  [2:0]     dvalid_r;
	reg  [1:0]     vsync_r;
	reg  [1:0]     alg_sel_shadow;

	wire [13:0]   data_tmp1;
	wire [13:0]   data_tmp2;
	wire [13:0]   data_tmp3;
	wire          data_tmp4;
	wire [2:0]    data_tmp5;
	wire [13:0]   data_tmp6;
	wire [13:0]   data_tmp7;
	wire [7:0]    data_tmp8;
	wire [7:0]    data_tmp9;
	wire [15:0]   nc_rem;
	wire [15:0]   denom;

	reg [13:0]    min_value_tmp;
	reg [13:0]    max_value_tmp;
	reg [20:0]    en;
	wire          cal_en;
	assign min_value = min_value_tmp;
	assign max_value = max_value_tmp;
   
	always @(posedge clk)
	begin
		dvalid_r[2:0] <= #1 ({dvalid_r[1:0], dvalid});
		vsync_r[1:0] <= #1 ({vsync_r[0], vsync});
	end
   
  assign data_tmp1 = ((max_pixel >= din)) ? max_pixel : 
                      din;
  assign data_tmp2 = ((min_pixel <= din)) ? min_pixel : 
                      din;
   
	always @(posedge clk)
	begin
		if (vsync == 1'b1)
		begin
			max_pixel <= #1 {14{1'b0}};
			min_pixel <= #1 {14{1'b1}};
		end
		else if (dvalid == 1'b1)
		begin
			max_pixel <= #1 data_tmp1;
			min_pixel <= #1 data_tmp2;
		end
	end
   
  assign data_tmp3 = ((max_value_tmp <= min_value_tmp)) ? {13'b0,1'b1} :
                      max_value_tmp - min_value_tmp;
  assign max_pixel_sel = ((alg_sel_shadow[1:0] == 2'b01)) ? max_pixel : 
                          highIndex;
  assign min_pixel_sel = ((alg_sel_shadow[1:0] == 2'b01)) ? min_pixel : 
                          lowIndex;
   
	always @(posedge clk)
	begin
		if (vsync == 1'b1 & ((~(vsync_r[0]))) == 1'b1)
		begin
			max_value_tmp <= #1 max_pixel_sel;
			min_value_tmp <= #1 min_pixel_sel;
		end
		if ((vsync_r[0]) == 1'b1 & ((~(vsync_r[1]))) == 1'b1)
			diff <= data_tmp3;
		if (en[20] == 1'b1 & en[19] == 1'b0)
			slope <= quotient;
		if ((vsync_r[1]) == 1'b1 & ((~(vsync_r[0]))) == 1'b1)
			en <= ({en[19:0], 1'b1});
		else
			en <= ({en[19:0], 1'b0});
	end
   
  assign cal_en = en[0] | en[1] | en[2] | en[3] | en[4] | en[5] | en[6] | en[7] | en[8] | en[9] | en[10] | en[11] | en[12] | en[13] | en[14] | en[15] | en[16] | en[17] | en[18] | en[19] | en[20];
   
  assign data_tmp4 = vsync & alg_sel[0] & ((~(alg_sel[1])));
  assign denom = ({2'b00, diff});
   
  slope_cal cal_slope(
		.clken(cal_en), 
		.clock(clk), 
		.denom(denom),       //分母
		.numer(16'hFF00),    //分子
		.quotient(quotient), //商
		.remain(nc_rem)      //余数
	);
   
  assign data_tmp5 = ((shift_pos >= 3'b110)) ? 3'b110 : 
                      shift_pos;
   
	always @(posedge clk)
	begin
		if ((vsync_r[1]) == 1'b1 & ((~(vsync_r[0]))) == 1'b1)
		begin
			shift_pos_shadow <= #1 data_tmp5;
			alg_sel_shadow <= #1 alg_sel;
		end
	end
   
   assign data_tmp6 = ((din >= max_value_tmp)) ? max_value_tmp : 
                      (din - min_value_tmp);
   assign data_tmp7 = ((din <= min_value_tmp)) ? {14{1'b0}} : 
                      data_tmp6;
   assign data_tmp8 = (((linear_shadow_pos[7]) == 1'b1)) ? linear_shadow_pos[15:8] + 8'b00000001 : 
                      linear_shadow_pos[15:8];
   assign data_tmp9 = (((linear_shadow_pos[15:7] == 12'h1ff) | (linear_shadow_pos[29:16] != 12'h000))) ? 8'b11111111 : 
                      (data_tmp8);
   
  always @(posedge clk)   
	begin
		if (dvalid == 1'b1)
		begin
			case (shift_pos_shadow)
				3'b000 :
					shift_dout <= #1 din[13:6];
				3'b001 :
					shift_dout <= #1 din[12:5];
				3'b010 :
					shift_dout <= #1 din[11:4];
				3'b011 :
					shift_dout <= #1 din[10:3];
				3'b100 :
					shift_dout <= #1 din[9:2];
				3'b101 :
					shift_dout <= #1 din[8:1];
				default :
					shift_dout <= #1 din[7:0];
			endcase
			linear_shadow_pre <= #1 data_tmp7;
		end
		if ((dvalid_r[0]) == 1'b1)
			linear_shadow_pos <= #1 (linear_shadow_pre * slope);
		if ((dvalid_r[1]) == 1'b1)
			linear_dout <= data_tmp9;
	end
    
  always @(posedge clk)
	case (alg_sel_shadow[1:0])
		2'b00 :
			begin
				dout <= #1 shift_dout;
				dout_valid <= #1 dvalid_r[0];
			end
		2'b01, 2'b10 :
			begin
				dout <= #1 linear_dout;
				dout_valid <= #1 dvalid_r[2];
			end
		default :
			;
	endcase
   
endmodule

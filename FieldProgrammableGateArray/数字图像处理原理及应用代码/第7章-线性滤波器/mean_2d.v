//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 3? 16 2016 10:56:33
//
//      Input file      : 
//      Component name  : mean_2d
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module Mean_2D(rst_n, clk, din_valid, din, din_delay, din_valid_delay, dout, vsync, vsync_out, is_boarder, dout_valid);
   
   parameter                DW = 14;
   parameter                KSZ = 15;
   parameter                IH = 512;
   parameter                IW = 640;
   
   input                    rst_n;
   input                    clk;
   input                    din_valid;
   input [DW-1:0]           din;
   output [DW-1:0]          din_delay;
   output                   din_valid_delay;
   output [2*DW-1:0]        dout;
   input                    vsync;
   output                   vsync_out;
   output                   is_boarder;
   output                   dout_valid;
   
   
   
   parameter                radius = ((KSZ >> 1));
   parameter                num_all = KSZ * KSZ;
   parameter                fifo_num = KSZ - 1;
   parameter                med_idx = ((num_all >> 1));
   parameter                DW_ADD = DW * 2;
   
   reg                      rst_all;
   reg [DW-1:0]             line_din[0:KSZ-2];
   wire [DW-1:0]            line_dout[0:KSZ-2];
   
   wire [KSZ-2:0]           line_empty;
   wire [KSZ-2:0]           line_full;
   wire [KSZ-2:0]           line_rden;
   wire [KSZ-2:0]           line_wren;
   wire [9:0]               line_count[0:KSZ-2];
   
   wire                     din_valid_r;
   
   reg [KSZ-2:0]            buf_pop_en;
   reg                      valid_r;
   
   reg [10:0]               in_line_cnt;
   reg [15:0]               flush_cnt;
   reg                      flush_line;
   reg [15:0]               out_pixel_cnt;
   reg [10:0]               out_line_cnt;
   reg [2*DW-1:0]           dout_temp_r;
   reg [10:0]               dout_valid_temp_r;
   wire [2*DW-1:0]          dout_temp;
   wire                     dout_valid_temp;
   
   wire [2*DW-1:0]          sum_row7;
   wire [2*DW-1:0]          sum_row8;
   wire [2*DW-1:0]          sum_row9;
   wire [2*DW-1:0]          sum_row10;
   wire [2*DW-1:0]          sum_row11;
   wire [2*DW-1:0]          sum_row12;
   wire [2*DW-1:0]          sum_row13;
   wire [2*DW-1:0]          sum_row14;
   wire [2*DW-1:0]          sum_1_2;
   wire [2*DW-1:0]          sum_col_r;
   wire [2*DW-1:0]          sum_col[0:KSZ-1];
   wire [2*DW-1:0]          sum_all;
   wire                     is_boarder_tmp;
   reg                      is_boarder_r;
   
   wire [KSZ-1:0]           sum_valid;
   reg [radius-1+10:0]      din_valid_tmp;
   reg [(radius+10)*DW-1:0] din_tmp;
   
   reg [2*DW-1:0]           sum_tmp1;
   reg [2*DW-1:0]           sum_tmp2;
   reg [2*DW-1:0]           sum_tmp6;
   reg [2*DW+1:0]           sum_tmp3;
   reg [2*DW+1:0]           sum_tmp4;
   reg [2*DW+1:0]           sum_tmp5;
   wire                     valid;
   
   wire [31:0]              j;
   
   wire                     sum_all_valid;
   wire [DW_ADD*2-1:0]      add_all;
   
   wire [DW*2*KSZ-1:0]      data_tmp1;
   wire [DW*2-1:0]          data_tmp2;
   
   wire                     dout_valid_tmp;
   assign dout_valid = dout_valid_tmp;
   assign valid = din_valid | flush_line;
   
   always @(posedge clk or posedge rst_n)
      if (((~(rst_n))) == 1'b1)
         rst_all <= #1 1'b1;
      else 
      begin
         if (vsync == 1'b1)
            rst_all <= #1 1'b1;
         else
            rst_all <= #1 1'b0;
      end
   generate
      begin : xhdl0
         genvar                   i;
         for (i = 0; i <= KSZ - 2; i = i + 1)
         begin : buf_inst
            if (i == 0)
            begin : xhdl4
               always @(*) line_din[i] <= din;
               assign line_wren[i] = valid;
            end
            
            if ((~(i == 0)))
            begin : xhdl5
               always @(*) line_din[i] <= line_dout[i - 1];
               assign line_wren[i] = line_rden[i - 1];
            end
            
            
            line_buffer line_buf_inst(.rst(rst_all), .clk(clk), .din(line_din[i]), .dout(line_dout[i]), .wr_en(line_wren[i]), .rd_en(line_rden[i]), .empty(line_empty[i]), .full(line_full[i]), .count(line_count[i]));
            assign line_rden[i] = buf_pop_en[i] & valid;
            
            always @(posedge clk)
               
               begin
                  if (rst_all == 1'b1)
                     buf_pop_en[i] <= #1 1'b0;
                  else if (line_count[i] == IW)
                     buf_pop_en[i] <= #1 1'b1;
               end
            
            
            Sum_1D #(DW, KSZ) row_sum(.clk(clk), .din(line_dout[i]), .din_valid(line_rden[i]), .dout(sum_col[i + 1]), .dout_valid(sum_valid[i + 1]));
         end
      end
   endgenerate
   
   
   Sum_1D #(DW, KSZ) row_sum_din(.clk(clk), .din(din), .din_valid(din_valid), .dout(sum_col[0]), .dout_valid(sum_valid[0]));
   
   assign sum_row7 = (((sum_valid[6]) == 1'b1)) ? sum_col[7] : 
                     {2*DW-1+1{1'b0}};
   assign sum_row8 = (((sum_valid[7]) == 1'b1)) ? sum_col[8] : 
                     {2*DW-1+1{1'b0}};
   assign sum_row9 = (((sum_valid[8]) == 1'b1)) ? sum_col[9] : 
                     {2*DW-1+1{1'b0}};
   assign sum_row10 = (((sum_valid[9]) == 1'b1)) ? sum_col[10] : 
                      {2*DW-1+1{1'b0}};
   assign sum_row11 = (((sum_valid[10]) == 1'b1)) ? sum_col[11] : 
                      {2*DW-1+1{1'b0}};
   assign sum_row12 = (((sum_valid[11]) == 1'b1)) ? sum_col[12] : 
                      {2*DW-1+1{1'b0}};
   assign sum_row13 = (((sum_valid[12]) == 1'b1)) ? sum_col[13] : 
                      {2*DW-1+1{1'b0}};
   assign sum_row14 = (((sum_valid[13]) == 1'b1)) ? sum_col[14] : 
                      {2*DW-1+1{1'b0}};
   
   assign data_tmp1 = ({sum_col[0], sum_col[1], sum_col[2], sum_col[3], sum_col[4], sum_col[5], sum_col[6], sum_row7, sum_row8, sum_row9, sum_row10, sum_row11, sum_row12, sum_row13, sum_row14});
   
   AddTree #(DW_ADD, KSZ) sum_total(.rst_n(rst_n), .clk(clk), .din_valid(sum_valid[7]), .din(data_tmp1), .dout(add_all), .dout_valid(sum_all_valid));
   assign sum_all = add_all[DW_ADD - 1:0];
   
   always @(posedge clk)
      
      begin
         if (sum_all_valid == 1'b1)
         begin
            sum_tmp1 <= ({5'b00000, sum_all[2 * DW - 1:5]} + ({3'b000, sum_all[2 * DW - 1:8]}));
            sum_tmp2 <= ({1'b0, sum_all[2 * DW - 1:1]} + ({5'b00000, sum_all[2 * DW - 1:6]}));
            sum_tmp3 <= ({sum_all[2 * DW - 1:0], 2'b00}) + ({13'b0000000000000, sum_all[2 * DW - 1:11]});
         end
         if ((dout_valid_temp_r[0]) == 1'b1)
         begin
            sum_tmp4 <= #1 sum_tmp3 + ({2'b00, sum_tmp1});
            sum_tmp6 <= #1 sum_tmp2;
         end
         if ((dout_valid_temp_r[1]) == 1'b1)
            sum_tmp5 <= sum_tmp4 + ({2'b00, sum_tmp6});
      end
   
   assign dout_temp = (((sum_tmp5[6]) == 1'b1)) ? ({5'b00000, sum_tmp5[2 * DW + 1:7]} + 1'b1) : 
                      ({5'b00000, sum_tmp5[2 * DW + 1:7]});
   assign dout_valid_temp = dout_valid_temp_r[radius + 2];
   
   assign data_tmp2 = (((is_boarder_tmp | (~(dout_valid_temp_r[radius + 2]))) == 1'b1)) ? {DW+1{1'b0}} : 
                      dout_temp;
   
   always @(posedge clk)
      
      begin
         if (rst_all == 1'b1)
         begin
            dout_temp_r <= #1 {2*DW-1+1{1'b0}};
            dout_valid_temp_r <= #1 11'b00000000000;
            valid_r <= #1 1'b0;
            is_boarder_r <= 1'b0;
         end
         else
         begin
            dout_temp_r <= #1 data_tmp2;
            dout_valid_temp_r <= #1 ({dout_valid_temp_r[9:0], sum_all_valid});
            valid_r <= #1 valid;
            is_boarder_r <= is_boarder_tmp;
         end
      end
   
   assign dout = dout_temp_r;
   assign dout_valid_tmp = dout_valid_temp_r[radius + 3];
   assign is_boarder = is_boarder_r;
   
   

   always @(posedge clk)
      
      begin
         if (rst_all == 1'b1)
         begin
            din_valid_tmp <= {radius+10{1'b0}};
            din_tmp <= {radius+10*DW-1+1{1'b0}};
         end
         else
         begin
            din_valid_tmp <= #1 ({din_valid_tmp[radius - 2 + 10:0], line_rden[radius - 1]});
            din_tmp <= #1 ({din_tmp[(radius + 10) * DW - 1 - DW:0], line_dout[radius - 1]});
         end
      end
   
   assign din_valid_delay = din_valid_tmp[radius - 1 + 10];
   assign din_delay = din_tmp[(radius + 10) * DW - 1:(radius + 9) * DW];
   assign vsync_out = line_wren[radius - 1] & (~(line_wren[radius]));
   
endmodule

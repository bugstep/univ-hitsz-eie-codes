//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 3? 16 2016 10:56:24
//
//      Input file      : 
//      Component name  : localadapter_segmentation_2d
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module LocalAdapter_Segmentation_2D(rst_n, clk, din_valid, din, dout, vsync, vsync_out, is_boarder, dout_valid, algDone);
   parameter                        DW = 14;
   parameter                        KSZ = 15;
   parameter                        IH = 512;
   parameter                        IW = 640;
   input                            rst_n;
   input                            clk;
   input                            din_valid;
   input [DW-1:0]                   din;
   output [DW-1:0]                  dout;
   reg [DW-1:0]                     dout;
   input                            vsync;
   output                           vsync_out;
   output                           is_boarder;
   output                           dout_valid;
   output                           algDone;
   reg                              algDone;
   
   
   
   parameter                        radius = ((KSZ >> 1));
   parameter                        num_all = KSZ * KSZ;
   parameter                        fifo_num = KSZ - 1;
   parameter                        med_idx = ((num_all >> 1));
   
   parameter                        DW_MEAN = DW + 6;
   parameter                        DW_SQR = 2 * DW_MEAN;
   parameter                        DW_SQR_TOTAL = DW_SQR + 8;
   parameter                        KSZ_SQR = num_all;
   
   reg                              rst_all;
   
   wire                             din_valid_r;
   parameter                        latency = 8;
   parameter                        mean_latency = 9;
   parameter                        sigma_latency = 12;
   
   wire [DW-1:0]                    din_delay;
   wire                             din_valid_delay;
   wire [DW_MEAN-1:0]               dout_mean;
   wire                             mean_valid;
   reg [DW+3:0]                     diff[0:KSZ*KSZ-1];
   reg [KSZ*KSZ*DW_SQR-1:0]         square;
   reg                              mul_valid;
   reg                              mul_valid_r;
   reg                              mul_valid_r2;
   wire                             square_all_valid;
   reg                              square_all_valid_r;
   wire [DW_SQR_TOTAL-1:0]          square_all;
   
   reg [sigma_latency*DW_MEAN-1:0]  mean_delay_r;
   reg [mean_latency*DW-1:0]        din_delay_r;
   
   wire [KSZ*KSZ*DW-1:0]            din_new;
   reg [mean_latency-1:0]           din_valid_delay_r;
   
   reg [sigma_latency*DW-1:0]       din_org_r;
   wire [DW-1:0]                    din_org;
   reg [sigma_latency:0]            valid_r;
   reg [sigma_latency:0]            board_r;
   
   wire [KSZ-1:0]                   sum_valid;
   
   wire                             valid;
   
   wire                             mean_vsync;
   wire                             is_boarder_mean;
   
   wire                             new_boarder;
   wire                             din_new_valid;
   
   wire [DW-1:0]                    din_final;
   
   reg [DW_SQR_TOTAL-1:0]           square_org1;
   reg [DW_SQR_TOTAL-1:0]           square_org2;
   reg [DW_SQR_TOTAL-1:0]           square_org;
   reg [(DW_SQR_TOTAL)*latency-1:0] square_org_r;
   wire [DW_SQR_TOTAL+4-1:0]        square_org_last;
   
   wire [DW_SQR-1:0]                square_org_tmp;
   wire [DW_SQR_TOTAL+4-1:0]        square_tmp1;
   wire [DW_SQR_TOTAL+4-1:0]        square_tmp2;
   wire [DW_SQR_TOTAL+4-1:0]        square_tmp3;
   reg [DW_SQR_TOTAL+4-1:0]         sigma_square1;
   reg [DW_SQR_TOTAL+4-1:0]         sigma_square2;
   reg [DW_SQR_TOTAL+4-1:0]         sigma_square;
   
   wire [DW_SQR*2-1:0]              add_all;
   
   wire [DW*2-1:0]                  dout_mean_full;
   reg [DW+3:0]                     diff_tmp[0:KSZ*KSZ-1];
   wire [DW_SQR*KSZ_SQR-1:0]        square_all_input;
   wire [DW-1:0]                    dout_cmp;
   wire [DW-1:0]                    dout_no_board;
   
   reg [9:0]                        count_lines;
   assign valid = din_valid;
   
   always @(posedge clk or posedge rst_n)
      if (((~(rst_n))) == 1'b1)
         rst_all <= #1 1'b1;
      else 
      begin
         if (vsync == 1'b1)
            rst_all <= #1 1'b1;
         else
            rst_all <= #1 1'b0;
      end
   
   
   Mean_2D #(DW, 15, IH, IW) mean(.rst_n(rst_n), .clk(clk), .din(din), .din_valid(din_valid), .din_valid_delay(din_valid_delay), .din_delay(din_delay), .dout_valid(mean_valid), .vsync(vsync), .vsync_out(mean_vsync), .is_boarder(is_boarder_mean), .dout(dout_mean_full));
   
   assign dout_mean = dout_mean_full[DW_MEAN - 1:0];
   
   
   always @(posedge clk)
      
      begin
         if (rst_all == 1'b1)
         begin
            din_valid_delay_r <= {mean_latency{1'b0}};
            din_delay_r <= {mean_latency*DW-1+1{1'b0}};
         end
         else
         begin
            din_valid_delay_r <= #1 ({din_valid_delay_r[mean_latency - 2:0], din_valid});
            din_delay_r <= #1 ({din_delay_r[(mean_latency - 1) * DW - 1:0], din});
         end
      end
   
   
   window_buf #(DW, KSZ, IH, IW) orignal_buf(.rst_n(rst_n), .clk(clk), .din_valid(din_valid_delay_r[mean_latency - 1]), .din(din_delay_r[mean_latency * DW - 1:(mean_latency - 1) * DW]), .dout(din_new), .dout_org(din_org), .vsync(vsync), .is_boarder(new_boarder), .dout_valid(din_new_valid));
   
   always @(posedge clk or posedge rst_all)
      if (rst_all == 1'b1)
      begin
         mul_valid <= #1 1'b0;
         mul_valid_r <= #1 1'b0;
         mul_valid_r2 <= #1 1'b0;
         square_all_valid_r <= #1 1'b0;
      end
      else 
      begin
         mul_valid <= #1 din_new_valid & mean_valid & ((~(is_boarder_mean)));
         mul_valid_r <= #1 mul_valid;
         mul_valid_r2 <= #1 mul_valid_r;
         square_all_valid_r <= #1 square_all_valid;
      end
   
   generate
      begin : xhdl0
         genvar                           i;
         for (i = 0; i <= KSZ * KSZ - 1; i = i + 1)
         begin : cal_square
            always @(*) diff_tmp[i] <= ((({din_new[(i + 1) * DW - 1:(i) * DW], 4'b0000}) > dout_mean[DW + 5:2])) ? (({din_new[(i + 1) * DW - 1:(i) * DW], 4'b0000}) - dout_mean[DW + 5:2]) : 
                                       (dout_mean[DW + 5:2] - ({din_new[(i + 1) * DW - 1:(i) * DW], 4'b0000}));
            
            always @(posedge clk)
               
               begin
                  if (din_new_valid == 1'b1 & mean_valid == 1'b1 & (((~(is_boarder_mean)))) == 1'b1)
                     diff[i] <= #1 diff_tmp[i];
                  if (mul_valid == 1'b1)
                     square[(i + 1) * DW_SQR - 1:(i) * DW_SQR] <= #1 ({(diff[i] * diff[i]), 4'b0000});
               end
         end
      end
   endgenerate
   
   assign square_org_tmp = square[(med_idx + 1) * DW_SQR - 1:(med_idx) * DW_SQR];
   
   always @(posedge clk)
      
      begin
         if (mul_valid_r == 1'b1)
         begin
            square_org1 <= ({8'b00000000, square_org_tmp}) + ({1'b0, square_org_tmp, 7'b0000000});
            square_org2 <= ({2'b00, square_org_tmp, 6'b000000}) + ({3'b000, square_org_tmp, 5'b00000});
         end
         if (mul_valid_r2 == 1'b1)
            square_org <= square_org1 + square_org2;
         square_org_r <= ({square_org_r[(latency - 1) * DW_SQR_TOTAL - 1:0], square_org});
      end
   assign square_all_input = square[KSZ * KSZ * DW_SQR - 1:0];
   
   AddTree #(DW_SQR, KSZ_SQR) square_total(.rst_n(rst_n), .clk(clk), .din_valid(mul_valid_r), .din(square_all_input), .dout(add_all), .dout_valid(square_all_valid));
   
   assign square_all = add_all[DW_SQR_TOTAL - 1:0];
   
   assign square_tmp1 = ({1'b0, square_all, 3'b000}) + ({4'b0000, square_all});
   assign square_tmp2 = ({3'b000, square_all, 1'b0}) + ({8'b00000000, square_all[DW_SQR_TOTAL - 1:4]});
   assign square_tmp3 = ({5'b00000, square_all[DW_SQR_TOTAL - 1:1]}) - ({10'b0000000000, square_all[DW_SQR_TOTAL - 1:6]});
   
   always @(posedge clk)
      
      begin
         if (square_all_valid == 1'b1)
         begin
            sigma_square1 <= square_tmp1 + square_tmp3;
            sigma_square2 <= square_tmp2;
         end
         if (square_all_valid_r == 1'b1)
            sigma_square <= sigma_square1 + sigma_square2;
      end
   
   assign square_org_last = ({4'b0000, square_org_r[latency * DW_SQR_TOTAL - 1:(latency - 1) * DW_SQR_TOTAL]});
   assign din_final = din_org_r[(sigma_latency) * DW - 1:(sigma_latency - 1) * DW];
   assign dout_cmp = ((square_org_last > sigma_square)) ? din_final : 
                     {DW{1'b0}};
   assign dout_no_board = (((board_r[sigma_latency - 1] | (~(valid_r[sigma_latency - 1]))) == 1'b1)) ? {DW{1'b0}} : 
                          dout_cmp;

   
endmodule
